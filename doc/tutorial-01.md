# Tutorial 1 - The Basics

In this first tutorial we are going to create and configure a minimum
ClojureScript ([CLJS][1]) project by using the [boot][2] build tool.

## Install Boot

bla bla bla

## Create a project structure

A minimum CLJS web project is composed of 3 files:

* an html page
* a CLJS source code
* a `boot` build file to compile the CLJS

Even if CLJS does not dictate any directory structure, it's a good
practice to organize the files of your project in such away that it
will be easy for anyone, even yourself in a few months, to be able to
easily understand its structure. Moreover, each building tool has its
idiosyncrasies which they call defaults. The more you adhere to the
defaults of the tool in your hand, the less it will be your pain to
workaround them.

```bash mkdir -p modern-cljs/{src/cljs/modern_cljs,html} ```

* `modern-cljs` is the home directory of the project;
* `src/cljs/` hosts CLJS source code
* `html` hosts html resources;

    > NOTE 1: Single segment namespace are
    > [discouraged in CLJ/CLJS][3]. That's why we created the
    > `modern_cljs` directory as well: it will host our CLJS source
    > files. Due to [Java difficulties][4] in managing hyphen "-" (or
    > other special characters) in package names, we substituted an
    > underscore for any hyphen in corresponding directory names.

Let's now create the three needed files:

```bash
cd modern-cljs
touch html/index.html src/cljs/modern_cljs/core.cljs build.boot
```

> NOTE 2: Please note that the filename extension for ClojureScript
> source is *cljs*, not *clj*.

You should end up with the following project structure:

```bash
modern-cljs/
├── build.boot
├── html
│   └── index.html
└── src
    └── cljs
        └── modern_cljs
            └── core.cljs
```

## Hello World in CLJS

We're now going to write our very first CLJS code. Open the
`src/cljs/modern_cljs/core.cljs` file with your preferred editor and
cut and paste the following CLJS code:

```clj
;; create the main project namespace
(ns modern-cljs.core)

;; enable cljs to print to the JS console of the browser
(enable-console-print!)

;; print to the console
(println "Hello, World!")
```

Every CLJ/CLJS file must start with a namespace declaration matching a
path on disk (e.g. `(ns modern-cljs.core)` <-->
`modern_cljs/core.cljs`).

The `(enable-console-print!)` expression redirects any printing output
to the console of the browser.

Finally, the `(println "Hello, world!")`  prints `Hello, World!` to the
console.

## Minimal build.boot

We now need a way to compile down `core.cljs` to JS and finally link
it to the `index.html` page.

Open the file `html/index.html` and edit it as follow:

```html
<!doctype html>
<html>
  <head>
    <title>Hello, World!</title>
  </head>
  <body>
    <script src="main.js"></script>
  </body>
</html>
```

As you see there are no reference to CLJS. We only added a `<script>`
tag to link the `index.html` page to the `main.js` file. This JS file
will be generated by the `boot` building tool while compiling the
above `core.cljs` source code.

To compile down the `core.cljs` file, we need to instruct `boot` by
editing the `build.boot` file, which is just a regular CLJ file with a
different extension, as follow:

```cljs
(set-env!
 :source-paths #{"src/cljs"}
 :resource-paths #{"html"}

 :dependencies '[[adzerk/boot-cljs "1.7.48-6"]])

(require '[adzerk.boot-cljs :refer [cljs]])
```

Pretty minimal! The `set-env` function sets `:source-paths` and
`:resource-paths` keywords to the corresponding values of the project
structure as we have created above. Then it injects the `boot-cljs`
compilation task as the only explicit dependency of the project by
adding it to the `:dependencies` keyword. Note that we did not include
`clojure` and `clojurescript` dependencies. This is because a version
knowing to work with `boot-cljs` will be automagically added to the
project (i.e. CLJ 1.7.0 and CLJS 1.7.48).

Finally, the `require` form makes the `cljs` task visible to the
`boot` command. If you now run the `boot -h` command from the
terminal, you should now see that the `cljs` task is available to
`boot`.

```bash
boot -h
Boot App Version: 2.0.0-pre14
Boot Lib Version: 2.1.2
Clojure Version:  1.7.0

Usage:   boot OPTS <task> TASK_OPTS <task> TASK_OPTS ...

...

Tasks:   add-repo                   Add all files in project git repo to ...

         zip                        Build a zip file for the project.

         cljs                       Compile ClojureScript applications.
...

Do `boot <task> -h` to see usage info and TASK_OPTS for <task>.
```

We can even have more information about the `cljs` task by issuing the
following command:

```bash
boot cljs -h
Compile ClojureScript applications.
...
Available --optimization levels (default 'none'):
...
```

As you see, the default optimization directive for the CLJS compiler
is `:none`. Let's now see `'boot cljs` at work without specifing any
options on the command line.

```bash
boot cljs
Writing main.cljs.edn...
Compiling ClojureScript...
• main.js
```

Now you know why we named as `main.js` the JS file included in the
`<script>` tag of the `index.html` page: just to adhere to an easy
default to be used.

Let's see what has been generated by the copilation task:

```bash
.
├── boot.properties
├── build.boot
├── html
│   └── index.html
├── src
│   └── cljs
│       └── modern_cljs
│           └── core.cljs
└── target
    ├── index.html
    ├── main.js
    └── main.out
        ├── boot
        │   └── cljs
        │       ├── main494.cljs
        │       ├── main494.cljs.cache.edn
        │       ├── main494.js
        │       └── main494.js.map
        ├── cljs
        │   ├── core.cljs
        │   ├── core.js
        │   └── core.js.map
        ├── cljs_deps.js
        ├── goog
        │   ├── array
        │   │   └── array.js
        │   ├── asserts
        │   │   └── asserts.js
        │   ├── base.js
        │   ├── debug
        │   │   └── error.js
        │   ├── deps.js
        │   ├── dom
        │   │   └── nodetype.js
        │   ├── object
        │   │   └── object.js
        │   └── string
        │       ├── string.js
        │       └── stringbuffer.js
        └── modern_cljs
            ├── core.cljs
            ├── core.cljs.cache.edn
            ├── core.js
            └── core.js.map

17 directories, 27 files
```

WOW, a lot of stuff. As you see the original directory structure is
untouched. Everything, even the `index.html` resource, has been
generated into the `target` directory, which you could set in the
`set-env!` call by setting the `:target-path` kyeword/value pair:

```cljs
;; set target to a different value
(set-env!
  :target-path "resources/public"
...
)
```

So far, so good.

## Visit index.html

Open a browser and visit the local `target/index.html` file. Now open
the console in your Development Tool (e.g. Chrome Development Tool).
If everything went ok, you should see "Hello, World!" printed in the
console.

## Next Step - [Tutorial 2: Browser CLJS REPL (bREPL)][]

In the next [tutorial][6] we're introduce the so called *brepl*, a browser
connected CLJS REPL.

# License

Copyright © Mimmo Cosenza, 2012-2015. Released under the Eclipse Public
License, the same as Clojure.

[1]: https://github.com/clojure/clojurescript.git
[2]: http://boot-clj.com/
[3]: http://stackoverflow.com/questions/13567078/whats-wrong-with-single-segment-namespaces
[4]: http://docs.oracle.com/javase/specs/jls/se8/html/jls-6.html
[5]: https://github.com/magomimmo/modern-cljs/blob/master/doc/tutorial-02.md
