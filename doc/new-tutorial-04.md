# Tutorial 4 - ClojureScript Quick Tutorial

In the [previous tutorial][1] we ended up with an almost complete
Immediate Feedback Development Environment (IFDE). Even if in a next
tutorial we'll add a `test` task to support the TDD (Test Driven
Development) methodology, we can now start to learn a little bit of
the ClojureScript language.

> NOTE 1: in this tutorial we're including most of the content of the
> [ClojureScript Tutorial][3] by [David Nolen][4], the amazing and
> tireless maintaniner of the CLJS language.

## Preamble

If you want to start working from the end of the [previous tutorial][1],
assuming you've [git][2] installed, do as follows.

```bash
git clone https://github.com/magomimmo/modern-cljs.git
cd modern-cljs
git checkout se-tutorial-03
git checkout -b cljs-tutorial-step-1
```
If you created a new git branch, as suggested in the preamble of the
tutorial, quit everything and commit the changes.

```bash
git commit -am "modern javascript"
```

## Launch the IFDE

Start by launching the IFDE environment.

```bash
cd /path/to/modern-cljs
boot dev
...
Compiling ClojureScript...
• js/main.js
Elapsed time: 20.539 sec
```

Visit the `http://localhost:3000` URL in your browser. Open the
Developent Tool of the browser. If you see the `Hello, World!`
message, it means that your IFDE is correctely running.

Unless you have an editor/IDE able to connect to the `nrepl` server
running inside the IFDE, you should now launch a REPL client from a
new terminal window.

```bash
# from a new terminal window/console
cd /path/to/modern-cljs
boot repl -c
REPL-y 0.3.7, nREPL 0.2.11
Clojure 1.7.0
Java HotSpot(TM) 64-Bit Server VM 1.8.0_66-b17
        Exit: Control+D or (exit) or (quit)
    Commands: (user/help)
        Docs: (doc function-name-here)
              (find-doc "part-of-name-here")
Find by Name: (find-name "part-of-name-here")
      Source: (source function-name-here)
     Javadoc: (javadoc java-object-or-class-here)
    Examples from clojuredocs.org: [clojuredocs or cdoc]
              (user/clojuredocs name-here)
              (user/clojuredocs "ns-here" "name-here")
boot.user=>
```

Launch the bREPL from the nREPL

```clj
boot.user=> (start-repl)
<< started Weasel server on ws://127.0.0.1:50264 >>
<< waiting for client to connect ... Connection is ws://localhost:50264
Writing boot_cljs_repl.cljs...
 connected! >>
To quit, type: :cljs/quit
nil
cljs.user=>
```

After a while you should see the `connected!` notification and the
`cljs.user=>` bREPL prompt at the terminal. You should also see the
"Opened Websocket REPL connection" notification at the browser
console.

You are now ready to learn CLJS interacting with the bREPL.

# ClojureScript Quick Tutorial

## Introduction

Clojure (CLJ) is a modern LISP dialect hosted on the Java Virtual
Machine (JVM). ClojureScript (CLJS) is hosted on the JavaScript
Virtual Machine (JSVM). The CLJ compiler generates JVM bytecode, while
the CLJS compiler generates JS code. The JS code generated by the CLJS
compiler is compatible with the Google Clojure Compiler (GCC) and
internally uses the Google Closure Library (GCL) as well.

## Primitive Data Types

Even if CLJS offers almost the same primitive data types offered by
CLJ, there are few differeces to be taken into account.

## Numbers

CLJS numbers evaluate to themselves. 

```clj
cljs.user=> 42
42
cljs.user=> 42.0
42
```

CLJS numbers are mapped to JS numbers. For this reason the following
equality expression returns `true`:

```clj
cljs.user=> (= 42 42.0)
true
```

CLJS uses the LISP prefix notation. Here we compared `42` and `42.0`
for equality. In LISP `=` in not an operator, but a symbol which
happened to be associated with a funtion comparing its arguments for
equality.

Even if the prefix notation could appear unfamiliar at the very
beginning, it has two advantages over the most familiar infix
notation:

* a function can be easily defined with different arities and to accept
  an undefined number of arguments

```clj
cljs.user=> (+)
0
cljs.user=> (+ 1)
1
cljs.user=> (+ 41)
41
cljs.user=> (+)
0
cljs.user=> (+ 41)
41
cljs.user=> (+ 40 1)
41
cljs.user=> (+ 39 1 2)
42
cljs.user> (*)
1
cljs.user> (* 1)
1
cljs.user> (* 6 7)
42
cljs.user> (* 2 3 7)
42
```

* there is no need to remember any rule about operators' precedences:

```clj
cljs.user> (* (* 2 3)
              (+ 3 4))
42
cljs.user> (= 42
              (* 6 7)
              (* 2 3 7)
              (+ 41 1)
              (+ 39 1 2))
true
```

Aside from the regular arithmetic functions (i.e. `+`, `-`, `*`. `/`,
`quot`, `rem`, `mod`, `inc`, `dec`, `min`, `max`, etc), CLJS offers
the access to the functions defined in the JS `Math` object.

```clj
cljs.user> (Math.sqrt 9)
3
cljs.user> (Math.random)
0.5622905471827835
cljs.user> (Math.sin 0)
0
```

## Strings

CLJS strings are directely mapped to JS literal strings and are
immutable as well. Strings evaluate to themselves.

```clj
cljs.user> "Hello, World!"
"Hello, World!"
cljs.user> "Hello, 
World!"
"Hello, \nWorld!"
```

If you implicitely mix numbers and strings, the CLJS compiler will
notify you a warning:

```clj
cljs.user> (+ 1 "2")
WARNING: cljs.core/+, all arguments must be numbers, got [number string] instead. at line 1 <cljs repl>
"12"
cljs.user> (+ "1" "2")
WARNING: cljs.core/+, all arguments must be numbers, got [string string] instead. at line 1 <cljs repl>
"12"
```

If you really want to concatenate numbers into strings, use the `str`
function:

```clj
cljs.user> (str)
""
cljs.user> (str 1)
"1"
cljs.user> (str 1 2)
"12"
```

CLJS defines a large number of functions in the `clojure.string`
namespace. To access from your active namespace (i.e. `cljs.user`) the
the public symbols of a CLJS namespace, you need to require it.

```clj
cljs.user> (require '[clojure.string :as s])
nil
```

You can now use any public symbol defined in the `clojure.string`
namespace by separating the symbol of the namespace from the symbol of
the function with the `/` character:

```clj
cljs.user> (clojure.string/blank? "")
true
```

The `:as s` portion of the above requirement expression allows to
shorten your function calls by creating an alias for the required
namespace.

```clj
cljs.user> (s/blank? " ")
true
cljs.user> (s/reverse "Hello, World!")
"!dlroW ,olleH"
```

# Chars

CLJS maps chars into JS strings, because JS does not have the char
type.

```clj
cljs.user> \a
"a"
cljs.user> (= \a "a")
true
```

# Lists

As said, CLJS is a LISP dialect hosted on a JSVM and the LISP acronym
stands for LISt Processing. It's not a surprise that CLJS uses lists
as well, as you already saw in few of the above expressions we
evaluated at the bREPL.

A list is just a pair of parentheses, `(...)`, containing zero or more
expressions. The void list, `()`, evaluate to itself.

```clj
cljs.user> ()
()
```

CLJS, offering more collections types if compared to other LISP
dialect, does not use lists to much. 


CLJS offers 
# Next Step Tutorial 5: TBD

# License

Copyright © Mimmo Cosenza, 2012-15. Released under the Eclipse Public
License, the same as Clojure.

[1]: https://github.com/magomimmo/modern-cljs/blob/master/doc/tutorial-03.md
[2]: https://help.github.com/articles/set-up-git
