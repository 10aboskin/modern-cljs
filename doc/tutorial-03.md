# Tutorial 3 - House Keeping

In the [previous tutorial][1] we started approaching the Immediate
Feedback Principle by Bret Victor by using the `boot` building tool
and piping few additional tasks developed by the community:

* `boot-cljs`: to compile CLJS source code (introduced in
  [Tutorial-01][2]);
* `boot-http`: to run a CLJ based web server to serve pages;
* `boot-reload`: to reload static resources when changes are saved;
* `boot-cljs-repl`: to connect a CLJS REPL to the JS engine of the
  browser (bREPL).

In this tutorial we're going to improve the developer interaction with
the `boot` building tool by minimizing the length of the `boot`
commands to be submitted to the terminal, while supporting the immediate
feedback style of programming.

## Preamble

If you want to start working from the end of the [previous tutorial][1],
assuming you've `git` installed, do as follows.

```bash
git clone https://github.com/magomimmo/modern-cljs.git
cd modern-cljs
git checkout se-tutorial-02
git checkout -b tutorial-03-step-1
```

This way you're cloning the original `se-tutorial-02` branch into a
new branch to start working with.

## Introduction

Let's start reviewing the `boot` commands we previously submitted to
the terminal to progressively approach the Immediate Feedback
Principle.

### CLJS compilation

First, in [Tutorial-01][2] we configured few environment
variables. Namely `:source-paths` and `:resource-paths`.

Then we launched the CLJS compilation with the following very simple
`boot` command:

```bash
boot cljs
```

We did not pass any compilation option to the task by exployting few
available defaults. Namely:

* `none` as compiler optimization;
* `source-map` defaulted to `true` with the `none` optimization
* `main.js` as the name of JS file generated by the compiler
* `"target"` as name of the directory under which `main.js` is
  saved.

    > NOTE 1: ClojureScript supports HTML source maps so that you can
    > debug ClojureScript directly in the browser, using the
    > configuration option `source-map`. Under optimizations `none`
    > the valid values are `true` and `false`, with the default being
    > true. Under all other optimization settings must specify a path
    > to where the source map will be written (extracted from
    > [ClojureScript Compiler Optimizations][3]).

### HTTP server

In [Tutorial-02][1] we started by adding the `serve` task to the
`boot` command. We passed it the `-d target` option to instruct the
task about the main directory to serve. They could have used the same
`target` default as they did for `cljs`, but they did not. So we
needed to be specific.

As you could remember, we also needed to add the `wait` task for
keeping the https server running.

the `serve` and `cljs` tasks.

```bash
boot wait serve -d target cljs
```

### CLJS recompilation

To trigger the CLJS recompilation when we modify and save a CLJS
source file, we substituted the `wait` task with `watch` task which
requires to be positioned before the `cljs` task.

```bash
boot serve -d target watch cljs
```

### boot-reload

Again, to trigger the reloading of static resources when we save their
changes or changes in the CLJS source code they link, we added the
`reload` task to the pipeline before just before the `cljs` task.

```bash
boot serve -d target watch reload cljs
```

### bREPL

Last, but not least, to almost complete our intent of approaching the
Immediate Feedback Principle by offering a browser base REPL (bREPL),
we had to add at the end of the pipeline the `cljs-repl` task. Dont't
forget to antepone the `cljs-repl` task to the `cljs` one.

```bash
boot serve -d target watch reload cljs-repl cljs
```

If you complain about the things you have to remember just to start
playing around your project, you're right.

This is why `boot` core developers offer you a very confortable way to
help your typing and your memory.

## Enter deftask

From the user point of view, one the interesting aspects of `boot` is
the composable nuture of its tasks, whether predefined by `boot` or
not. You could spend days in studying `boot` source code to better
unserstand its architectures, but we want to be pragmatic. At the
moment we are only interested in reducing the need of memorizing task
names and order while launching the `boot` command.

All we have to do is to open the `build.boot` and define a new task as
an ordered composition of other tasks by using the `deftask` macro as
follows:

```clj
(set-env!
 :source-paths #{"src/cljs"}
 :resource-paths #{"html"}
 
 :dependencies '[[org.clojure/clojure "1.7.0"]
                 [org.clojure/clojurescript "1.7.122"]
                 [adzerk/boot-cljs "1.7.48-6"]
                 [pandeiro/boot-http "0.7.0"]
                 [adzerk/boot-reload "0.4.1"]
                 [adzerk/boot-cljs-repl "0.2.0"]])

(require '[adzerk.boot-cljs :refer [cljs]]
         '[pandeiro.boot-http :refer [serve]]
         '[adzerk.boot-reload :refer [reload]]
         '[adzerk.boot-cljs-repl :refer [cljs-repl start-repl]])

;; define dev task as composition of subtasks
(deftask dev
  "Launch Immediate Feedback Development Environment"
  []
  (comp 
   (serve :dir "target")
   (watch)
   (reload)
   (cljs-repl) ;; before cljs task
   (cljs)))
```

First, note the use of `comp` function in the body of the newly
created `dev` via the `deftask` macro. If you do not know CLJ
[`transducers`][4] you could be surpriced by observing it uses the
same tasks order of the corresponding `boot` command call.

Let's start a CLJ repl:

```bash
boot repl
...
boot.user=>
```

and ask for the documentation string attached to `comp`:

```cljs
boot.user=> (doc comp)
-------------------------
clojure.core/comp
([] [f] [f g] [f g & fs])
  Takes a set of functions and returns a fn that is the composition
  of those fns.  The returned fn takes a variable number of args,
  applies the rightmost of fns to the args, the next
  fn (right-to-left) to the result, etc.
nil
boot.user=>
```

The composed functions are applied from righ-to-left. Lets see it at
work. Suppose we want to count the even integers in a vector. We can
use the `comp` function as follows:

```clj
boot.user=> ((comp count filter) even? [3 2 5 4 7 9])
2
```

If, instead, we want to count the odd integers in a vector, we just
need to substitute the 'even?` predicate:

```clj
boot.user=> ((comp count filter) odd? [3 2 5 4 7 9])
4
```

So, how it is possibile that the `comp` function, when used to compose
a new task from a number of subtasks uses a left-to-rigth order of
function application instead of a right-to-left order?

## Next step - [Tutorial 4: Modern ClojureScript][7]

In the [next tutorial 4][7] we're going to have some fun introducing
form validation in CLJS.

# License

Copyright Â© Mimmo Cosenza, 2012-2014. Released under the Eclipse Public
License, the same as Clojure.

[1]: https://github.com/magomimmo/modern-cljs/blob/master/doc/tutorial-02.md
[2]: https://github.com/magomimmo/modern-cljs/blob/master/doc/tutorial-01.md
[3]: https://github.com/clojure/clojurescript/wiki/Compiler-Options#source-map
[4]: http://clojure.org/transducers

