# Tutorial 3 - House Keeping

In the [previous tutorial][1] we started approaching the Immediate
Feedback Principle by Bret Victor by using the `boot` building tool
and piping few additional tasks developed by the community:

* `boot-cljs`: to compile CLJS source code (introduced in
  [Tutorial-01][2]);
* `boot-http`: to run a CLJ based web server to serve pages;
* `boot-reload`: to reload static resources when changes are saved;
* `boot-cljs-repl`: to connect a CLJS REPL to the JS engine of the
  browser (bREPL).

In this tutorial we're going to improve the developer interaction with
the `boot` building tool by minimizing the length of the `boot`
commands to be submitted to the terminal while supporting the immediate
feedback style of programming.

## Preamble

If you want to start working from the end of the [previous tutorial][1],
assuming you've `git` installed, do as follows.

```bash
git clone https://github.com/magomimmo/modern-cljs.git
cd modern-cljs
git checkout tutorial-03
git checkout -b tutorial-03-step-1
```

This way you're cloning the `tutorial-02` branch into a new branch to
start working with.

## Introduction

Let's start reviewing the `boot` commands we previously submitted to
the terminal to progressively approach the Immediate Feedback
Principle.

### CLJS compilation

First we configured few environment variables. Namely `:source-paths`
and `:resource-paths`.

Then we launched the CLJS compilation with the following very simple
`boot` command:

```bash
boot cljs
```

We did not pass any compilation option to the task by exployting a few
defaults. Namely:

* `none` compiler optimization;
* `main.js` as the name of JS file generated by the compiler
* `"target"` as the name of the directory under which `main.js` is
  saved.

### HTTP server

In the [Tutorial-02][1] we started adding the `serve` task to the
pipe. We passed it the `-d target` option to instruct the task about
the main directory to serve. They could have used the same default,
but they did not, so we needed to be specific.

As you could remember, we also needed to interpose the `wait` task
between the `serve` and `cljs` tasks.

To launch the CLJS based server together with the CLJS compilation
task we submitted the following `boot` pipelined command:

```bash
boot serve -d target wait cljs
``

Here we had to add the predefined `wait` task to let the `serve` task
run forever. The `boot` command start to become more aritculated and
we also need to remember the tasks order anytime we launch the
command.

### CLJS recompilation

To trigger the CLJS recompilation executed by the `cljs` task, we
added the predefined `watch` task to the `boot` command pipeline by
positioning it immediatley before the `cljs` task itself.

```bash
boot serve -d target wait watch cljs
```

### boot-reload

Again, to trigger the reloading of static resources when we save their
changes or chenges in the CLJS source code they link, we added a new
task, `reload`, to the `boot` pipeline, and the order of tasks matters
as well.

```bash
boot serve -d target wait watch reload cljs
```

### bREPL

Last, but not least, to almost complete our intent of approaching the
Immediate Feedback Principle by offering a browser base REPL (bREPL),
we had to add in the right position the `cljs-repl` task too.

```bash
boot serve -d target wait watch reload cljs cljs-repl
```

If you complain about the things you have to remember just to start
playing around your project, you're right.

This is why `boot` main developers though to offer you a very
confortable way to help your typing and your memory.

## Enter deftask

From the user point of view the most interesting aspect of `boot` is
the composable nuture of its tasks. You can even composose tasks by
mixing *atomic* tasks with tasks that are composed of other tasks. A
kind of `composite design pattern` in OO parlance.

Let's be pragmatic. At the moment we only want to reduce the need of
memorizing task names and order while launching the `boot` command to
adhere to the Immediate Feddback Principle as much as we can.

All we have to do is to define new tasks as an ordered composition of
other tasks.




are them selvescomposed tasks.

`boot` is directley inspired to the composable nature of [`ring`][3]
handlers/middleware.

Any task in `boot` is composable with other tasks to implement any
kind of functionality already offered by [`Leiningen`][4], the *de
facto* standard CLJ building tool.

The explanation of `boot` architecture is outside the scope of
`modern-cljs` series of tutorials and we'll concetrated our attention
to the use of `boot` and its available tasks, instead of explaining
how you could define a new `boot` taks by yourself.



Let's review the final `build.boot` attached to the `modern-cljs`
inital project.

```clj
(set-env!
 :source-paths #{"src/cljs"}
 :resource-paths #{"html"}
 
 :dependencies '[[org.clojure/clojure "1.7.0"]
                 [org.clojure/clojurescript "1.7.122"]
                 [adzerk/boot-cljs "1.7.48-6"]
                 [pandeiro/boot-http "0.6.3"]
                 [adzerk/boot-reload "0.4.1"]
                 [adzerk/boot-cljs-repl "0.2.0"]])

(require '[adzerk.boot-cljs :refer [cljs]]
         '[pandeiro.boot-http :refer [serve]]
         '[adzerk.boot-reload :refer [reload]]
         '[adzerk.boot-cljs-repl :refer [cljs-repl start-repl]])
```


## Next step - [Tutorial 4: Modern ClojureScript][7]

In the [next tutorial 4][7] we're going to have some fun introducing form validation in CLJS.

# License

Copyright Â© Mimmo Cosenza, 2012-2014. Released under the Eclipse Public
License, the same as Clojure.

[1]: https://github.com/magomimmo/modern-cljs/blob/master/doc/tutorial-02.md
[2]: https://github.com/magomimmo/modern-cljs/blob/master/doc/tutorial-01.md


[2]: https://github.com/ring-clojure/ring
[3]: https://github.com/weavejester/lein-ring
[4]: http://ring-clojure.github.com/ring/
[5]: https://github.com/weavejester/compojure.git
[6]: http://localhost:3000/simple.html
[7]: https://github.com/magomimmo/modern-cljs/blob/master/doc/tutorial-04.md
[8]: https://help.github.com/articles/set-up-git
