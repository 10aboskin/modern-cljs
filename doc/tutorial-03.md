# Tutorial 3 - House Keeping

In the [previous tutorial][1] we started approaching the Immediate
Feedback Principle by Bret Victor by using the `boot` building tool
and piping few additional tasks developed by the community:

* `boot-cljs`: to compile CLJS source code (introduced in
  [Tutorial-01][2]);
* `boot-http`: to run a CLJ based web server to serve pages;
* `boot-reload`: to reload static resources when changes are saved;
* `boot-cljs-repl`: to connect a CLJS REPL to the JS engine of the
  browser (bREPL).

In this tutorial we're going to improve the developer interaction with
the `boot` building tool by minimizing the length of the `boot`
commands to be submitted to the terminal, while supporting the immediate
feedback style of programming.

## Preamble

If you want to start working from the end of the [previous tutorial][1],
assuming you've `git` installed, do as follows.

```bash
git clone https://github.com/magomimmo/modern-cljs.git
cd modern-cljs
git checkout se-tutorial-02
git checkout -b tutorial-03-step-1
```

This way you're cloning the original `se-tutorial-02` branch into a
new branch to start working with.

## Introduction

Let's start reviewing the `boot` commands we previously submitted to
the terminal to progressively approach the Immediate Feedback
Principle.

### CLJS compilation

First, in [Tutorial-01][2] we configured few environment
variables. Namely `:source-paths` and `:resource-paths`.

Then we launched the CLJS compilation with the following very simple
`boot` command:

```bash
boot cljs
```

We did not pass any compilation option to the task by exployting few
available defaults. Namely:

* `none` as compiler optimization;
* `source-map` defaulted to `true` with the `none` optimization
* `main.js` as the name of JS file generated by the compiler
* `"target"` as name of the directory under which `main.js` is
  saved.

    > NOTE 1: ClojureScript supports HTML source maps so that you can
    > debug ClojureScript directly in the browser, using the
    > configuration option `source-map`. Under optimizations `none`
    > the valid values are `true` and `false`, with the default being
    > true. Under all other optimization settings must specify a path
    > to where the source map will be written (extracted from
    > [ClojureScript Compiler Optimizations][3]).

### HTTP server

In [Tutorial-02][1] we started by adding the `serve` task to the
`boot` command. We passed it the `-d target` option to instruct the
task about the main directory to serve. They could have used the same
`target` default as they did for `cljs`, but they did not. So we
needed to be specific.

As you could remember, we also needed to add the `wait` task for
keeping the https server running.

the `serve` and `cljs` tasks.

```bash
boot wait serve -d target cljs
```

### CLJS recompilation

To trigger the CLJS recompilation when we modify and save a CLJS
source file, we substituted the `wait` task with `watch` task which
requires to be positioned before the `cljs` task.

```bash
boot serve -d target watch cljs
```

### boot-reload

Again, to trigger the reloading of static resources when we save their
changes or changes in the CLJS source code they link, we added the
`reload` task to the pipeline before just before the `cljs` task.

```bash
boot serve -d target watch reload cljs
```

### bREPL

Last, but not least, to almost complete our intent of approaching the
Immediate Feedback Principle by offering a browser base REPL (bREPL),
we had to add at the end of the pipeline the `cljs-repl` task. Dont't
forget to antepone the `cljs-repl` task to the `cljs` one.

```bash
boot serve -d target watch reload cljs-repl cljs
```

If you complain about the things you have to remember just to start
playing around your project, you're right.

This is why `boot` core developers offer you a very confortable way to
help your typing and your memory.

## Enter deftask

From the user point of view, one the interesting aspects of `boot` is
the composable nuture of its tasks, whether predefined by `boot` or
not. You could spend days in studying `boot` source code to better
unserstand its architectures, but we want to be pragmatic. At the
moment we are only interested in reducing the need of memorizing task
names and order while launching the `boot` command from the terminal.

All we have to do is to open the `build.boot` and define a new task as
an ordered composition of other tasks by using the `deftask` macro as
follows:

```clj
(set-env!
  ...
  ...)

(require ...
         ...)

;; define dev task as composition of subtasks
(deftask dev
  "Launch Immediate Feedback Development Environment"
  []
  (comp 
   (serve :dir "target")
   (watch)
   (reload)
   (cljs-repl) ;; before cljs task
   (cljs)))
```

Note the use of `comp` function in the body of the newly created `dev`
via the `deftask` macro. The `comp` function composes the same tasks
with the same order we saw in the `boot` command. The only difference
is the way the `"target"` value is passed to `serve` subtask as a
`:dir` keyword argument instead of as command-line argument.

The newly defined `dev` task is now available to be used at the
command-line:

```bash
boot -h
...
         dev                        Launch immediate feedback dev environ...
...
Do `boot <task> -h` to see usage info and TASK_OPTS for <task>.
```

You can now launch the `dev` task as usual from the command line to
get the same effect you previously obtained by composing its subtasks:

```bash
boot dev
Starting reload server on ws://localhost:60083
Writing boot_reload.cljs...
Writing boot_cljs_repl.cljs...
2015-11-04 08:58:55.742:INFO:oejs.Server:jetty-7.6.13.v20130916
2015-11-04 08:58:55.788:INFO:oejs.AbstractConnector:Started SelectChannelConnector@0.0.0.0:3000
<< started Jetty on http://localhost:3000 >>

Starting file watcher (CTRL-C to quit)...

nREPL server started on port 60086 on host 127.0.0.1 - nrepl://127.0.0.1:60086
Writing main.cljs.edn...
Compiling ClojureScript...
• main.js
Elapsed time: 19.929 sec
```

You can then repeat all the tests we already shown in [Tutorial-02][1]
including the bREPL creation from a nrepl client.

Not bad. You now have a very simple command, `boot dev`, to launch a
development environment approaching the Immediate Feedback Principle.

When you finish with your experimenting, kill everything.


## Next step - [Tutorial 4: Modern ClojureScript][7]

In the [next tutorial 4][7] we're going to have some fun introducing
form validation in CLJS.

# License

Copyright © Mimmo Cosenza, 2012-2014. Released under the Eclipse Public
License, the same as Clojure.

[1]: https://github.com/magomimmo/modern-cljs/blob/master/doc/tutorial-02.md
[2]: https://github.com/magomimmo/modern-cljs/blob/master/doc/tutorial-01.md
[3]: https://github.com/clojure/clojurescript/wiki/Compiler-Options#source-map
[4]: http://clojure.org/transducers

